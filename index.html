<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Raymarching Shader</title>
    <style>
        body, html {
            margin: 0; padding: 0; overflow: hidden;
            background: #111;
            height: 100vh;
        }
        canvas {
            display: block;
            width: 100vw; height: 100vh;
        }
    </style>
</head>
<body>

<canvas id="glcanvas"></canvas>

<script id="fragShader" type="x-shader/x-fragment">#version 300 es
    precision highp float;

    out vec4 FragColor;

    uniform vec3 u_CameraPos;
    uniform vec3 u_LightPos;
    uniform float u_Time;
    uniform vec2 u_Resolution;
    uniform vec3 u_Forward;
    uniform vec3 u_Right;
    uniform vec3 u_Up;

    // Capped Torus SDF (Inigo Quilez)
    float sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb) {
        p.x = abs(p.x);
        float k = (sc.y * p.x > sc.x * p.y) ? dot(p.xy, sc) : length(p.xy);
        return sqrt(dot(p, p) + ra * ra - 2.0 * ra * k) - rb;
    }

    float sdSphere( vec3 p, float s )
    {
        return length(p)-s;
    }

    float smin( float a, float b, float k )
    {
        k *= log(2.0);
        float x = b-a;
        return a + x/(1.0-exp2(x/k));
    }

    float sub( float d1, float d2 )
    {
        return max(-d1,d2);
    }

    float sdBox( vec3 p, vec3 b )
    {
        vec3 q = abs(p) - b;
        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
    }

    float sdPlane( vec3 p, vec3 n, float h )
    {
        // n must be normalized
        return dot(p,n) + h;
    }

    float map(in vec3 pos, in vec3 rd) {
        float spacing = 1.0;
        vec3 q = pos;
        q.xyz = mod(q.xyz + spacing * 0.5, spacing) - spacing * 0.5;
        float an = 2.5 * (0.5 + 0.5 * sin(u_Time * 1.1 + 3.0));
        vec2 c = vec2(sin(an), cos(an));
        //    float torusDist = sdCappedTorus(pos, c, 0.4, 0.1);
        float torusDist = sdSphere(q - vec3(0.0, 0.0, 0.0), 0.7);
        float boxDist = sdBox(q - vec3(0.0, 0.0, 0.0), vec3(0.5, 0.5, 0.5));
        float planeDist = sdPlane(pos, vec3(0.0, 1.0, 0.0), 0.5);
        return sub(torusDist, boxDist);
    }

    vec3 calcNormal(in vec3 pos, in vec3 rd) {
        vec2 e = vec2(1.0, -1.0) * 0.5773;
        const float eps = 0.0005;
        return normalize(
        e.xyy * map(pos + e.xyy * eps, rd) +
        e.yyx * map(pos + e.yyx * eps, rd) +
        e.yxy * map(pos + e.yxy * eps, rd) +
        e.xxx * map(pos + e.xxx * eps, rd)
        );
    }

    void main() {
        vec2 uv = (gl_FragCoord.xy / u_Resolution) * 2.0 - 1.0;
        uv.x *= u_Resolution.x / u_Resolution.y;

        vec3 ro = u_CameraPos;
        vec3 rd = normalize(uv.x * u_Right + uv.y * u_Up + 1.5 * u_Forward);

        const float tmax = 120.0;
        float t = 0.0;
        float dist;
        for (int i = 0; i < 128; i++) {
            vec3 pos = ro + rd * t;
            dist = map(pos, rd);
            if (dist < 0.001 || t > tmax) break;
            t += dist;
        }

        vec3 fogColor = vec3(169.0 / 255.0);
        float fogDensity = 0.1;

        vec3 col = vec3(161.0 / 255.0, 227.0 / 255.0, 249.0 / 255.0);
        if (t < tmax) {
            float fogFactor = exp(-t * fogDensity);
            fogFactor = clamp(fogFactor, 0.0, 1.0);

            vec3 def = vec3(179.0 / 255.0, 16.0 / 255.0, 51.0 / 255.0);

            vec3 pos = ro + rd * t;
            vec3 nor = calcNormal(pos, rd);
            vec3 lightDir = normalize(u_LightPos - pos);

            float diff = clamp(dot(nor, lightDir), 0.0, 1.0);
            float amb = 0.2;

            vec3 viewDir = normalize(u_CameraPos - pos);
            vec3 reflectDir = reflect(-lightDir, nor);
            float spec = pow(max(dot(viewDir, reflectDir), 0.0), 64.0);

            vec3 ambient = vec3(0.1);
            vec3 diffuse = vec3(0.8, 0.7, 0.5) * diff;
            vec3 specular = vec3(1.0) * spec;

            col = ambient + diffuse;
            col = mix(col, def, 1.0);
            col = mix(fogColor, col, fogFactor);
            col += specular;
        }

        col = pow(col, vec3(0.4545));
        FragColor = vec4(col, 1.0);
    }
</script>

<script id="vertShader" type="x-shader/x-vertex">#version 300 es
    precision highp float;

    in vec4 position;

    void main() {
        gl_Position = position;
    }


</script>

<script>
    (() => {
        const canvas = document.getElementById('glcanvas');
        const gl = canvas.getContext('webgl2');

        if (!gl) {
            alert("WebGL2 not supported");
            return;
        }

        const keys = {};

        window.addEventListener('keydown', (e) => {
            keys[e.code] = true;
        });

        window.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        // Setup canvas size
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resize);
        resize();

        // Compile shader
        function compileShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error("Shader compile error: ", gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Create program
        function createProgram(vsSource, fsSource) {
            const vertexShader = compileShader(gl.VERTEX_SHADER, vsSource);
            const fragmentShader = compileShader(gl.FRAGMENT_SHADER, fsSource);
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.bindAttribLocation(program, 0, 'position');
            gl.linkProgram(program);
            if(!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error("Program link error: ", gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        const vertSource = document.getElementById('vertShader').textContent;
        const fragSource = document.getElementById('fragShader').textContent;

        const program = createProgram(vertSource, fragSource);
        gl.useProgram(program);

        // Fullscreen quad
        const quadVertices = new Float32Array([
            -1, -1,
            1, -1,
            -1,  1,
            -1,  1,
            1, -1,
            1,  1,
        ]);
        const vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        const vbo = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        gl.bufferData(gl.ARRAY_BUFFER, quadVertices, gl.STATIC_DRAW);
        const positionLoc = gl.getAttribLocation(program, 'position');
        gl.enableVertexAttribArray(positionLoc);
        gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

        // Uniform locations
        const u_Resolution = gl.getUniformLocation(program, 'u_Resolution');
        const u_Time = gl.getUniformLocation(program, 'u_Time');
        const u_CameraPos = gl.getUniformLocation(program, 'u_CameraPos');
        const u_LightPos = gl.getUniformLocation(program, 'u_LightPos');
        const u_Forward = gl.getUniformLocation(program, 'u_Forward');
        const u_Right = gl.getUniformLocation(program, 'u_Right');
        const u_Up = gl.getUniformLocation(program, 'u_Up');

        // Camera setup
        const forward = [0, 0, 1];
        const right = [1, 0, 0];
        const up = [0, 1, 0];
        const lightPos = [5, 5, -5];

        function render(time) {
            time *= 0.001;

            processInput();

            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(program);
            gl.bindVertexArray(vao);

            gl.uniform2f(u_Resolution, canvas.width, canvas.height);
            gl.uniform1f(u_Time, time);

            gl.drawArrays(gl.TRIANGLES, 0, 6);

            requestAnimationFrame(render);
        }
        requestAnimationFrame(render);

        let cameraPos = [0, 0, -3];
        let yaw = Math.PI / 2; // 90 градусов
        let pitch = 0;

        let lastX, lastY;
        let firstMouse = true;

        function onMouseMove(e) {
            let dx = e.movementX || 0;
            let dy = e.movementY || 0;

            yaw += dx * 0.0025;
            pitch -= dy * 0.0025;

            // Clamp pitch to avoid flipping
            let limit = Math.PI / 2;
            pitch = Math.max(-limit, Math.min(limit, pitch));
        }

        canvas.addEventListener('click', () => {
            canvas.requestPointerLock();
        });

        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement === canvas) {
                console.log("Pointer locked");
                document.addEventListener('mousemove', onMouseMove);
            } else {
                console.log("Pointer unlocked");
                document.removeEventListener('mousemove', onMouseMove);
            }
        });

        function getForwardVector() {
            let x = Math.cos(yaw) * Math.cos(pitch);
            let y = Math.sin(pitch);
            let z = Math.sin(yaw) * Math.cos(pitch);
            // нормализация
            let len = Math.hypot(x, y, z);
            return [x / len, y / len, z / len];
        }

        function cross(a, b) {
            return [
                a[1]*b[2] - a[2]*b[1],
                a[2]*b[0] - a[0]*b[2],
                a[0]*b[1] - a[1]*b[0]
            ];
        }

        function normalize(v) {
            let len = Math.hypot(...v);
            return v.map(x => x / len);
        }

// В каждом кадре при обработке ввода:

        function processInput() {
            let speed = 0.07;

            let forward = getForwardVector();
            let worldUp = [0, 1, 0];
            let right = normalize(cross(forward, worldUp));
            let up = normalize(cross(right, forward));

            if (keys['KeyW']) {
                cameraPos = cameraPos.map((c, i) => c + forward[i] * speed);
            }
            if (keys['KeyS']) {
                cameraPos = cameraPos.map((c, i) => c - forward[i] * speed);
            }
            if (keys['KeyA']) {
                cameraPos = cameraPos.map((c, i) => c - right[i] * speed);
            }
            if (keys['KeyD']) {
                cameraPos = cameraPos.map((c, i) => c + right[i] * speed);
            }
            if (keys['Space']) {
                cameraPos[1] += speed;
            }
            if (keys['ShiftLeft']) {
                cameraPos[1] -= speed;
            }

            // Update uniforms:
            gl.uniform3fv(u_Forward, forward);
            gl.uniform3fv(u_Right, right);
            gl.uniform3fv(u_Up, up);
            gl.uniform3fv(u_CameraPos, cameraPos);
        }


    })();
</script>

</body>
</html>
